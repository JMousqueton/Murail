<!doctype html>
<html lang="fr" data-bs-theme="dark">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Animateur ‚Äì Simulation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
  <circle cx='30' cy='50' r='20' stroke='black' stroke-width='5' fill='lightgray'/>
  <circle cx='70' cy='50' r='20' stroke='black' stroke-width='5' fill='lightgray'/>
  <rect x='25' y='30' width='50' height='10' fill='black'/>
</svg>">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body { background:#0b0f14; color:#fff; }
      .small-muted { color:#9aa0a6; }
      .timeline .item{ border:1px solid rgba(255,255,255,.12); border-radius:.75rem; padding:.75rem 1rem; }
      .timeline .past { opacity:.7; }
      .timeline .next { border-color:#ffc107; box-shadow:0 0 0 .15rem rgba(255,193,7,.15); }
      .arrow { color:#ffc107; }
    </style>
  </head>
  <body>
    <div class="container py-3">
      <div class="d-flex align-items-center justify-content-between mb-3">
        <h1 class="h5 m-0">Mode Animateur</h1>
        <div>
          {% if n_tweets > 0 and n_messages > 0 %}
            <span class="badge bg-success">Sc√©nario charg√©</span>
          {% else %}
            <span class="badge bg-danger">Sc√©nario vide</span>
          {% endif %}
        </div>
      </div>

      <div class="row g-3 mb-3">
        <div class="col-sm-6"><div class="p-3 border rounded-3">Tweets planifi√©s : <strong>{{ n_tweets }}</strong></div></div>
        <div class="col-sm-6"><div class="p-3 border rounded-3">Messages planifi√©s : <strong>{{ n_messages }}</strong></div></div>
      </div>

      <h2 class="h6 mb-2">Timeline (messages uniquement)</h2>

      <div class="timeline d-flex flex-column gap-2 mb-4" id="timeline">
        <!-- sections rendered by JS -->
      </div>
    </div>

    <script>
      // ---------- Initial data from server (safe-JSON) ----------
      const INITIAL_PAST5 = {{ past5 | tojson }};
      const INITIAL_NEXT1 = {{ next1 | tojson }};
      const INITIAL_NEXT2 = {{ next2 | tojson }};
      const META_BY_ID    = {{ meta_by_id | tojson }};

      // ---------- Utils ----------
      function hhmmFromMs(ms){
        return new Date(ms).toLocaleTimeString('fr-FR', { hour:'2-digit', minute:'2-digit' });
      }
      function escapeHtml(s){
        return String(s ?? '')
          .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      }

      // Merge helpers: normalize objects we‚Äôll store in memory
      function normalizeEvent(e){
        // server provides: e.at (ISO), e.msg_id, e.label
        // SSE provides: id, at_ms, label, reaction, commentaire
        if (!e) return null;
        const id   = e.msg_id || e.id;
        const ms   = ('at_ms' in e) ? e.at_ms : (e.at ? Date.parse(e.at) : NaN);
        const meta = META_BY_ID[id] || { reaction: e.reaction || "", commentaire: e.commentaire || "" };
        return {
          id,
          label: e.label || "",
          at_ms: ms,
          reaction: meta.reaction || "",
          commentaire: meta.commentaire || "",
        };
      }

      // hold all events we have seen
      const events = [];

      function upsertEvent(ev){
        if (!ev || !ev.id) return;
        const i = events.findIndex(x => x.id === ev.id);
        if (i >= 0) {
          // keep earliest data (at_ms shouldn‚Äôt change), but update meta if needed
          events[i] = { ...events[i], ...ev };
        } else {
          events.push(ev);
        }
      }

      // seed with initial server-rendered lists
      for (const e of (INITIAL_PAST5 || [])) {
        const n = normalizeEvent(e);
        if (n) upsertEvent(n);
      }
      if (INITIAL_NEXT1) {
        const n = normalizeEvent(INITIAL_NEXT1);
        if (n) upsertEvent(n);
      }
      if (INITIAL_NEXT2) {
        const n = normalizeEvent(INITIAL_NEXT2);
        if (n) upsertEvent(n);
      }

      // Rendering
      const timeline = document.getElementById('timeline');

      function render(){
  // sort by time
  events.sort((a,b)=> a.at_ms - b.at_ms);
  const now = Date.now();
  const past = events.filter(e => e.at_ms < now);
  const future = events.filter(e => e.at_ms >= now);

  //const past5 = past.slice(-5);
  const past5 = past.slice(-3);
  const next1 = future[0] || null;
  const next2 = future[1] || null;   // <-- always try to fetch one more

  function card(html, extraClass=""){
    return `<div class="item ${extraClass}">${html}</div>`;
  }
  function badge(id){
    return `<span class="badge bg-warning text-dark">${escapeHtml(id || '')}</span>`;
  }
  function metaLines(e){
    const parts = [];
    if (e.reaction) parts.push(`<div class="mt-1">üîé <span class="small-muted">r√©action attendue :</span> ${escapeHtml(e.reaction)}</div>`);
    if (e.commentaire) parts.push(`<div>üìù <span class="small-muted">commentaire :</span> ${escapeHtml(e.commentaire)}</div>`);
    return parts.join('');
  }

  const blocks = [];

  // --- past5 ---
  if (past5.length) {
    for (const e of past5) {
      blocks.push(card(`
        ${badge(e.id)}
        <strong class="ms-2">${escapeHtml(e.label)}</strong>
        <div class="small-muted">${hhmmFromMs(e.at_ms)}</div>
        ${metaLines(e)}
      `, "past"));
    }
  } else {
    blocks.push(`<div class="text-secondary">Aucun message pass√©.</div>`);
  }

  // --- next1 ---
  if (next1) {
    blocks.push(card(`
      <span class="arrow me-2">‚ûú</span>
      ${badge(next1.id)}
      <strong class="ms-2">${escapeHtml(next1.label)}</strong>
      <div class="small-muted">${hhmmFromMs(next1.at_ms)}</div>
      ${metaLines(next1)}
    `, "next"));
  } else {
    blocks.push(`<div class="text-secondary">Aucun prochain message.</div>`);
  }

  // --- next2 ---
  if (next2) {
    blocks.push(card(`
      ${badge(next2.id)}
      <strong class="ms-2">${escapeHtml(next2.label)}</strong>
      <div class="small-muted">${hhmmFromMs(next2.at_ms)}</div>
      ${metaLines(next2)}
    `));
  } else {
    blocks.push(`<div class="text-secondary">Pas d‚Äôautre message planifi√©.</div>`);
  }

  timeline.innerHTML = blocks.join('\n');
}

      // initial render
      render();

      // Re-render every 10s so the ‚Äúpast/next‚Äù boundaries stay fresh
      setInterval(render, 10_000);

      // ---------- SSE: live updates ----------
      const evt = new EventSource("{{ url_for('stream_animateur') }}");
      evt.addEventListener('animateur', (e) => {
        try {
          const payload = JSON.parse(e.data);
          if (Array.isArray(payload)) {
            for (const m of payload) {
              const n = normalizeEvent(m);
              if (n) upsertEvent(n);
            }
            render();
          }
        } catch {}
      });
      evt.addEventListener('ping', () => {});
      evt.onerror = () => { /* let the browser auto-reconnect */ };
    </script>
<footer class="text-center mt-5 p-3 bg-dark text-light">
    <p>¬© 2025 <a href="https://github.com/JMousqueton/REMPAR" target="_blank">Julien Mousqueton</a></p>
    <p>bas√© sur l'exercice REMPAR25 de l'ANSSI</p>
  </footer>
    {{ TRACKING | safe }}
  </body>
</html>
